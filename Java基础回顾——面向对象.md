---
title: 面向对象
date: 2017-08-20 13:41:32
categories: 
- JavaSE
---


## 三大特性
封装，继承，多态。

### 封装
把对象的属性和操作联合为一个整体，并且隐藏内部实现细节。例子，属性用private修饰，然后建立公有方法给属性赋值，并且在方法中控制给属性赋值的规则。

<!--more-->
### 继承
继承就是从已有的类中派生出新的类，新的类能够吸收已有类的数据和行为，并能扩展新的能力。一般将这个已有类称为父类或是基类，而新的类称为子类或派生类。在java继承特性中，只能实现单继承，也就是所有子类只能有一个父类，子类继承父类的关键字是extends后面跟上类名。

#### 几个注意点：
* 在父类中的私有属性或方法在子类中是不能被继承的
* 如果在父类中有一个带参的构造函数并且没有无参的构造函数，那么子类在继承父类之后，必须有相同构造函数并且函数中的第一条语句要调用父类中的构造函数，因为当你实例化出子类对象的时候，会先走到父类的构造函数中执行再回到子类的构造函数中。

#### 方法重写（覆盖）
子类中有和父类的重名方法我们叫做覆盖，也就是说重写了父类的方法，在调用的时候可以把两个类的方法看成一种，但是其实是不一样，在子类中通过this和super关键字可以区分出来，this调用的是本类的方法，super调用的是父类方法，属性也是一样

### 多态
多态性是指允许不同类的对象对同一消息作出响应，多态包括参数化和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名的问题。，多态的过程实质是一个抽象指令，让一组具有相同行为单具有不同内容的个体协同工作的这样的一个过程。

#### 多态的优点
* 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
* 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
* 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
* 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
* 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要

#### 多态实现
多态是在继承的基础上，实现的。多态实现的三个必要条件：
* 继承
* 方法的重写
* 父类引用指向子类对象； 例如：Animal an = new Dog（）；

#### 示例代码

```Java

public class StuA {
    public void say(StuD stu){
        System.out.println("D say Hello");
    }
    public void say(StuA stu){
        System.out.println("A say Hello");
    }

}

public class StuB extends StuA {
    public void say(StuA stu){
        System.out.println("A say Hello");
    }
    public void say(StuD stu){
        System.out.println("B say Hello");
    }

}

public class StuD extends StuA {
    public void say(StuA stu){
        System.out.println("A say Hello");
    }
    public void say(StuB stu){
        System.out.println("B say Hello");
    }

}

public static void main(String[] args) {
        StuA a = new StuA();
        StuB b = new StuB();
        StuD d = new StuD();
        a.say(b);
        a.say(d);
        b.say(a);
        b.say(b);
        d.say(d);
        d.say(d);
        
    }

```
以上来源[cnblogs](http://www.cnblogs.com/fanfu1/p/4518587.html)

## 抽象类和接口

### 抽象类
在《Java编程思想》一书中，将抽象类定义为“包含抽象方法的类”，但是后面发现如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。
抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。

包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：
* 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
* 抽象类不能用来创建对象；
* 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。
在其他方面，抽象类和普通的类并没有区别。

### 接口
对行为的抽象
接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。

### 抽象类和接口的区别
1.语法层面上的区别

* 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
* 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别
* 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

* 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

## 引申出设计模式的一些思想
### OO基础
*	抽象
*	封装
*	多态
*	继承

### OO原则
*	封装变化
*	多用组合，少用继承
*	针对接口编程，不针对实现编程
*	为交互对象之间的松耦合设计而努力
*	对拓展开放，对修改关闭
*	依赖抽象，不要依赖具体类