---
title: 策略模式
date: 2017-07-23 14:46:07
categories: 
- 设计模式
---

##	策略模式

本文为Head First设计模式第一章阅读笔记，以抽象类，接口的形式实现了“找出应用中可能需要变化之处，独立出来，不要和那些不需要变化的代码混在一起”,做到了一个易拓展，弹性的设计。
<!--more-->
本文案例，动物有名字，要吃饭，要睡觉。（书上案例，鸭子,飞）
首先第一直觉是建立一个抽象类或接口:
```+java
public abstract class Animal {
    
    public abstract void name();

    public abstract void eat();

    public abstract void sleep();
}
```
这样做遇到的问题：一只动物今天吃这个，明天吃那个，今天睡这，明天睡那（一个方法实现不同），就要在动物子类中做一些冗余，而这些方法部分是可以被其他动物使用的，完全可以封装起来，这些就是上面提到的需要变化的代码。而动物的名字的实现不会被其他动物使用。所以把吃饭和睡觉提取出来，做成接口，这样一个动物可以有多个吃饭，睡觉实现，动物可以方便地动态改变吃饭，睡觉，提升代码灵活性。在拓展性方面，新增一个动物类，需要同时增加其吃饭，睡觉行为的实现，而大部分实现已经在之前实现了，只需增加这个动物特殊的实现。其实使用了设计原则：多用组合，少用继承。
缺点汇总：
*	代码在多个子类中重复
*	运行时的行为不易改变
*	很难知道动物的所有的行为
*	牵一发动全身，会对其他子类造成不必要的改变

## 代码实现
**动物超类：**

```+java
public abstract class Animal {
    protected EatBehavior eatBehavior;
    protected SleepBehavior sleepBehavior;

    /**
     * 名字
     */
    public abstract void name();

    public void eat() {
        eatBehavior.eat();
    }

    public void sleep(){
        sleepBehavior.sleep();
    }

    public void setEatBehavior(EatBehavior eatBehavior) {
        this.eatBehavior = eatBehavior;
    }

    public void setSleepBehavior(SleepBehavior sleepBehavior) {
        this.sleepBehavior = sleepBehavior;
    }
}

```


**吃饭行为接口：**
```+java
public interface EatBehavior {
    void eat();
}
```

**睡觉行为接口：**
```+java
public interface SleepBehavior {
    void sleep();
}
```


**猫：**
```+java
public class Cat extends Animal {
    public Cat() {
        this.eatBehavior = new CatEat();
        this.sleepBehavior = new CatSleep();
    }

    @Override
    public void name() {
        System.out.println("My name is cat.");
    }

}
```

**吃饭行为接口实现：**
```+java
public class CatEat implements EatBehavior {
    @Override
    public void eat() {
        System.out.println("eat fish.");
    }
}
```

**睡觉行为接口：**
```+java
public class CatSleep implements SleepBehavior {
    @Override
    public void sleep() {
        System.out.println("sleep everywhere.");
    }
}
```

**测试：**
```+java
public class AnimalTest {
    @Test
    public void test(){
        Animal cat = new Cat();
        cat.name();
        cat.eat();
        cat.sleep();
        cat.setEatBehavior(new CatEat2());
        cat.eat();

        Animal viking = new Viking();
        viking.name();
        viking.eat();
        viking.sleep();
    }
}
```

## 定义
策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

## 代码地址
[代码地址](https://coding.net/u/YoKv/p/readingNotes/git/tree/master/design-patterns/src/main/java/space/aiyo/gettingStarted)  




