---
title: docker-概述
date: 2018-04-29 15:45:48
categories: 
- DevOps
---


# 容器引擎技术
<!--more-->
## 概览
各种虚拟机技术开启了云计算时代；而继虚拟化技术出现后，容器技术逐渐成为对云计算领域具有深远影响的变革技术。容器技术的发展和应用，将为各行业应用云计算提供了新思路，同时容器技术也将对云计算的交付方式、效率、PaaS平台的构建等方面产生深远的影响。

### 操作系统：
* CoreOS

### 集群管理
* kubernetes(k8s)
* Swarm
* Mesos

### 容器技术
* Docker
* rkt


附上
[容器引擎大战历史](https://www.kubernetes.org.cn/2250.html)
[Docker&Moby](https://www.cnblogs.com/micrari/p/6748072.html)
[Docker&Moby](https://www.kubernetes.org.cn/3402.html)

## Docker介绍
Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于 Go语言开发，并遵从Apache 2.0协议。
Docker 的核心理念是 Build, Ship, and Run Any App, Anywhere。

历经5年发展，Docker公司揭露了今年最新的Docker年度数据报告，从2013年3月PyCon大会上，Docker首度亮相之后，至今在Docker上的容器镜像下载次数已经超过了370亿次，容器化的应用有高达350万个。
![](/images/docker-m.jpg)
[链接](https://www.kubernetes.org.cn/3816.html)


## 为什么使用docker

docker解决了什么问题:

* 程序在我这运行得好好的，在你那怎么就不行了？
* 系统好卡，哪个进程把cpu给吃光了？
* 这套系统我已经搭建好了，要不你再搭建一遍？

docker意义:

* 加速dovops普及
* 变革现有paas平台
* 容器即服务（caas）
* 标准化的应用发布方式


# docker 基础概念

## 核心组件

* Docker
	* Docker Enterprise Edition
	* Docker Community Edition
		* Docker
		* Docker for Mac
		* Docker for Windows
* Docker Store
* Docker Hub
* Open-source projects
	* Docker Notary
	* Docker Registry
* Docker Machine
* Docker Compose
* Docker Cloud


## 容器技术框架与传统物理机或虚拟机比较

### 虚拟机
1. 资源占用多
虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。
2. 冗余步骤多
虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。
3. 启动慢
启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。

### Linux 容器
Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。
1. 启动快
容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。
2. 资源占用少
容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。
3. 体积小
容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。

### Docker
Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。

Docker 的主要用途，目前有三大类:
* 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。
* 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。
* 组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

## 开始Docker

### 镜像（Image）
操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

构建镜像可以使用Dockerfile直接构建，或者重命名已有镜像。
### 仓库（Repository）
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。
一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。

类似于maven git的版本仓库
[Sonatype Nexus](https://www.sonatype.com/docker)

### 容器（Container）
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。

前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。


[概念参考资料](https://yeasy.gitbooks.io/docker_practice/content/basic_concept/image.html)

# docker编排
 
## Docker Swarm集群管理
