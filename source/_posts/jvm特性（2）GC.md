---
title: jvm特性（2）GC
date: 2020-02-20 17:30:27
categories:
- Java进阶
---

# 垃圾回收算法
<!--more-->

### 引用计数
给对象添加一个引用计数器，有一个地方引用就+1，引用失效-1，当引用为0时，则没有引用可以被回收。
问题：两个对象相互循环引用，没有其他引用时，这两个对象永远不会被回收。

### 可达性分析
用GC Roots对象作为起始点，从这些节点往下搜索，所有在引用链上的对象都是可达的，所以当一个对象没有在GC Roots对象引用链上时就可以被回收了。

GC Roots对象来自:
* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法中的JNI引用的对象

##### 引用
* 强引用
* 软引用SoftReference
* 弱引用WeakReference
* 虚引用PhantomReference

##### finalize()方法
对象不在GC Roots引用链  -->  筛选是否有必要执行finalize()方法  -->  对象放置到F-Queue队列，由低级别线程执行方法，并且是异步的，不等方法执行完
  --> GC对队列中的对象进行第二次标记，若还不在GC Roots，则被标记需要被清理的对象 
  
  对象的finalize()方法只会被执行一次
  
  
  
# 垃圾收集算法

### 标记-清除算法
先标记，再清除

缺点：大量不连续的内存碎片，效率不高


### 复制算法
分两块内存空间，一个空间内存活的对象复制到另一块内存空间，然后将原来的内存空间清理。

缺点：内存使用率不高
这种算法分为Eden，From Survivor，To Survivor3个空间


### 标记-整理算法
先标记，然后让对象都向内存一端移动形成一块连续的内存空间，然后清理掉其他空间的对象

### 分代收集算法
新生代和老年代


# HotSpot的实现
问题：
* GC Roots树的建立如果通过逐个检查引用，效率不高
* 在清理过程中程序不能继续执行，会有GC停顿，如果停顿时间过长影响程序。

解决方案：
* 使用一组OopMap来存储整个映射，在类加载完时数据写入，能快速准确完成GC Roots枚举过程
* OopMap没有在每条指令生成，而在特定位置记录，这些位置叫安全点，程序执行到安全点停下来GC
* 安全区域指在一段代码中，引用关系不发生变化，那么这个区域都可以当作安全点



# 垃圾收集器

### Serial收集器
单线程，暂停所有用户线程，新生代采用复制算法，老年代使用标记-整理算法

简单高效

### ParNew收集器
是Serial收集器多线程版本


### Parallel Scavenge 收集器
是新生代收集器。关注点是高吞吐量，不在意停顿时间。

### Parallel Old 收集器
是 Parallel Scavenge 收集器老年代版本，使用多线程和标记-整理算法。

### CMS收集器
关注点是最短的停顿时间，使用标记-清除算法：
1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

已在jdk14中移除

### G1收集器
整体上是标记-清理算法的实现，局部来看是基于复制算法的实现。
将堆分为多个大小相等的独立区域（Region），避免整块Java堆进行垃圾收集。按照单个Region来进行垃圾回收（化整为零）
由Remembered Set避免全堆扫描，建立引用链。

* 并行与并发
* 分代收集
* 空间整合
* 可预测的停顿


运作步骤：
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

### ZGC （64位）
一种并发的、不分代的、基于Region且支持NUMA的压缩收集器，核心设计就是读屏障与彩色指针
保证应用停顿不会超过10ms
ZGC不分新生代和老年代
可并发的标记-整理算法实现

运作步骤：
1. 标记
2. 迁移
3. 重映射